use std::path::{Path, PathBuf};

use clap::Parser;

use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;

use tokio::io::AsyncWriteExt;
use tokio::time::Duration;

mod explain;
mod utils;

use utils::generate_struct;

use crate::explain::ExplainRoot;

#[derive(Parser)]
struct Cli {
    #[clap(short, long, default_value = "./src/queries/*.sql")]
    input_path: String,
    #[clap(short, long, default_value = "./src/generated_structs.rs")]
    output_path: String,
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();

    let args = Cli::parse();

    let password = rpassword::prompt_password("Your Trino password: ").unwrap();

    let client = trino::ClientBuilder::default()
        .password(&password)
        .timeout(Duration::from_secs(20))
        .build();

    let mut outfile = tokio::fs::File::create(&args.output_path)
        .await
        .expect("Failed to create output file");

    outfile
        .write_all(b"// this file was autogenerated by trino-codegen, don't touch!\n")
        .await
        .unwrap();

    let imports = vec![
        "use serde::Deserialize;\n",
        "use trino_codegen::utils::dates;\n",
        "use trino_codegen::utils::binary;\n",
        "use trino_codegen::utils::array;\n",
    ];

    for import in &imports {
        outfile.write_all(import.as_bytes()).await.unwrap();
    }

    for file in glob::glob(&args.input_path)
        .expect("Failed to read glob pattern")
        .flatten()
    {
        tracing::info!("Reading file: {:#?}", file);
        let query = tokio::fs::read_to_string(&file)
            .await
            .expect("Failed to read file");

        if file.file_name().unwrap().to_string_lossy().contains("test") {
            let res: Vec<serde_json::Value> = client
                .query(&query)
                .await
                .expect("Query failed to return results");
            tracing::debug!("res: {:#?}", res);
        }

        let res: ExplainRoot = client
            .query_once(format!("EXPLAIN (TYPE LOGICAL, FORMAT JSON) {}", query).as_str())
            .await
            .expect("Query failed to return results");

        let generated_struct = generate_struct(&res, &file);

        tracing::info!("Generated struct: {:#?}", generated_struct);
        tracing::info!("Writing to file: {:#?}", args.output_path);

        let amt = outfile
            .write(generated_struct.to_string().as_bytes())
            .await
            .expect("Failed to write to output file");

        tracing::info!("Wrote {:#?} bytes to file", amt);
        // Write a newline to the output file
        let _ = outfile
            .write(b"\n")
            .await
            .expect("Failed to write to output file");

        outfile
            .flush()
            .await
            .expect("Failed to flush output file to disk");
    }
}
